<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/blog/images/icons/favicon-16x16.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/blog/images/icons/favicon-32x32.png?v=2.0.1" type="image/png" sizes="32x32"><meta name="description" content="10 大经典排序算法（动图演示+ C 语言代码）                           时间、空间复杂度比较          排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性    冒泡排序 O(n2) O(n2) O(1) 稳定   选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定   插入排序 O(n2">
<meta property="og:type" content="article">
<meta property="og:title" content="10_大经典排序算法（动图演示+_C_语言代码）">
<meta property="og:url" content="http://121.196.57.169/blog/2020/06/30/10_%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA+_C_%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="10 大经典排序算法（动图演示+ C 语言代码）                           时间、空间复杂度比较          排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性    冒泡排序 O(n2) O(n2) O(1) 稳定   选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定   插入排序 O(n2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hKfmJibLGNooo53Viahqkd8Fu4P2cfibia4m0VJiaUmB5gGfsUgKISIMG4EQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9htSXlhWTMfA3icyrX13JjSgZSOibibH0qaiccvQLPryqRiawiaLYaqKSOTJjg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQ5xnBplCB1JYwrkCvJLfr0cr7DDTZY8razp7TLlfibIQkQtBdbLn0ibg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hlEtRTzLNKxgIQHUj7kMAyH7ViaOCyo22r3iaR25ic1LgM4q4llyOBu5SA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hia9hibzYxy67BFFCxI2L5FAmtZWiahfIc0XasMFvIRH6sXjnGwpXMjYCw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hZFACwMvVG9IMqENiaAibSR5wPgJCkZH8kmfOZcrUpWyxLWpG5Rh11JSg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQNqdTja9dCGls0V9Ve7JolUmUxbVtHlrybsmNC84jWHHibL9kLicw8BQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hjl4T0fCvUq2zCdEcGqyH1ic9bDXVStxQXWcypoAs5VQ499ABm6dicYbA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hJrHSX1wiaClKuPDnLtLNgZUIQ2NfbYFMlIUaYQ6qLGaoiaiaRXJLXV9bg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1">
<meta property="article:published_time" content="2020-06-30T04:00:59.223Z">
<meta property="article:modified_time" content="2020-07-03T07:20:19.341Z">
<meta property="article:author" content="ydm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hKfmJibLGNooo53Viahqkd8Fu4P2cfibia4m0VJiaUmB5gGfsUgKISIMG4EQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1"><meta name="keywords" content="ydm, Hexo"><meta name="description" content=""><title>10_大经典排序算法（动图演示+_C_语言代码） | Hexo</title><link ref="canonical" href="http://121.196.57.169/blog/2020/06/30/10_%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA+_C_%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%89/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/blog/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/blog/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hexo</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">10_大经典排序算法（动图演示+_C_语言代码）</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-03</span></span></div></header><div class="post-body">
        <h2 id="10-大经典排序算法（动图演示-C-语言代码）">
          <a href="#10-大经典排序算法（动图演示-C-语言代码）" class="heading-link"><i class="fas fa-link"></i></a>10 大经典排序算法（动图演示+ C 语言代码）</h2>
      
        <h2 id="时间、空间复杂度比较">
          <a href="#时间、空间复杂度比较" class="heading-link"><i class="fas fa-link"></i></a>时间、空间复杂度比较</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">排序算法</th>
<th align="left">平均时间复杂度</th>
<th align="left">最差时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td align="left">O(n2)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">选择排序</td>
<td align="left">O(n2)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">数组不稳定、链表稳定</td>
</tr>
<tr>
<td align="left">插入排序</td>
<td align="left">O(n2)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">快速排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n2)</td>
<td align="left">O(log2n)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">归并排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">计数排序</td>
<td align="left">O(n+m)</td>
<td align="left">O(n+m)</td>
<td align="left">O(n+m)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">桶排序</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
<td align="left">O(m)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">基数排序</td>
<td align="left">O(k*n)</td>
<td align="left">O(n2)</td>
<td align="left"></td>
<td align="left">稳定</td>
</tr>
</tbody></table></div>
<h2 id><a href="#" class="headerlink" title></a></h2>
        <h2 id="1-冒泡排序">
          <a href="#1-冒泡排序" class="heading-link"><i class="fas fa-link"></i></a>1 冒泡排序</h2>
      <p><strong>算法思想</strong>：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hKfmJibLGNooo53Viahqkd8Fu4P2cfibia4m0VJiaUmB5gGfsUgKISIMG4EQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">冒泡排序动图演示</p>

        <h3 id="代码：">
          <a href="#代码：" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i &#x3D;0 ; i&lt; n-1; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    for(int j &#x3D; 0; j &lt; n-i-1; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      if(a[j] &gt; a[j+1])</span><br><span class="line">      &#123;</span><br><span class="line">        int tmp &#x3D; a[j] ;  &#x2F;&#x2F;交换</span><br><span class="line">        a[j] &#x3D; a[j+1] ;</span><br><span class="line">        a[j+1] &#x3D; tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="2-选择排序">
          <a href="#2-选择排序" class="heading-link"><i class="fas fa-link"></i></a>2 选择排序</h2>
      <p><strong>算法思想</strong>：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li>以此类推，直到所有元素均排序完毕</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9htSXlhWTMfA3icyrX13JjSgZSOibibH0qaiccvQLPryqRiawiaLYaqKSOTJjg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">选择排序动图演示</p>

        <h3 id="代码：-1">
          <a href="#代码：-1" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex &#x3D; i;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F; 寻找最小的数</span><br><span class="line">                minIndex &#x3D; j;                 &#x2F;&#x2F; 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[minIndex];</span><br><span class="line">        arr[minIndex] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-1">
          <a href="#-1" class="heading-link"><i class="fas fa-link"></i></a>** **</h2>
      
        <h2 id="3-插入排序">
          <a href="#3-插入排序" class="heading-link"><i class="fas fa-link"></i></a>3 插入排序</h2>
      <p>**<br>**</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQ5xnBplCB1JYwrkCvJLfr0cr7DDTZY8razp7TLlfibIQkQtBdbLn0ibg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">插入排序动图演示</p>

        <h3 id="代码：-2">
          <a href="#代码：-2" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void print(int a[], int n ,int i)&#123;</span><br><span class="line">  cout&lt;&lt;i &lt;&lt;&quot;:&quot;;</span><br><span class="line">  for(int j&#x3D; 0; j&lt;8; j++)&#123;</span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void InsertSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i&#x3D; 1; i&lt;n; i++)&#123;</span><br><span class="line">    if(a[i] &lt; a[i-1])&#123;   &#x2F;&#x2F;若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><br><span class="line">      int j&#x3D; i-1;</span><br><span class="line">      int x &#x3D; a[i];     &#x2F;&#x2F;复制为哨兵，即存储待排序元素</span><br><span class="line">      a[i] &#x3D; a[i-1];           &#x2F;&#x2F;先后移一个元素</span><br><span class="line">      while(x &lt; a[j])&#123;   &#x2F;&#x2F;查找在有序表的插入位置</span><br><span class="line">        a[j+1] &#x3D; a[j];</span><br><span class="line">        j--;     &#x2F;&#x2F;元素后移</span><br><span class="line">      &#125;</span><br><span class="line">      a[j+1] &#x3D; x;     &#x2F;&#x2F;插入到正确位置</span><br><span class="line">    &#125;</span><br><span class="line">    print(a,n,i);      &#x2F;&#x2F;打印每趟排序的结果</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a[15] &#x3D; &#123;2，3,4,5,15，19，16，27，36，38，44，46，47，48，50&#125;;</span><br><span class="line">  InsertSort(a,15);</span><br><span class="line">  print(a,15,15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-2">
          <a href="#-2" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="4-快速排序">
          <a href="#4-快速排序" class="heading-link"><i class="fas fa-link"></i></a>4 快速排序</h2>
      <p><strong>算法思想</strong>：</p>
<ol>
<li>选取第一个数为基准</li>
<li>将比基准小的数交换到前面，比基准大的数交换到后面</li>
<li>对左右区间重复第二步，直到各区间只有一个数</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hlEtRTzLNKxgIQHUj7kMAyH7ViaOCyo22r3iaR25ic1LgM4q4llyOBu5SA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">快速排序动图演示</p>

        <h3 id="代码：-3">
          <a href="#代码：-3" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt;&amp; v, int low, int high) &#123;</span><br><span class="line">if (low &gt;&#x3D; high)&#x2F;&#x2F; 结束标志</span><br><span class="line">return;</span><br><span class="line">int first &#x3D; low;&#x2F;&#x2F; 低位下标</span><br><span class="line">int last &#x3D; high;&#x2F;&#x2F; 高位下标</span><br><span class="line">int key &#x3D; v[first];&#x2F;&#x2F; 设第一个为基准</span><br><span class="line"></span><br><span class="line">while (first &lt; last)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 将比第一个小的移到前面</span><br><span class="line">while (first &lt; last &amp;&amp; v[last] &gt;&#x3D; key)</span><br><span class="line">last--;</span><br><span class="line">if (first &lt; last)</span><br><span class="line">v[first++] &#x3D; v[last];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将比第一个大的移到后面</span><br><span class="line">while (first &lt; last &amp;&amp; v[first] &lt;&#x3D; key)</span><br><span class="line">first++;</span><br><span class="line">if (first &lt; last)</span><br><span class="line">v[last--] &#x3D; v[first];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">v[first] &#x3D; key;</span><br><span class="line">&#x2F;&#x2F; 前半递归</span><br><span class="line">QuickSort(v, low, first - 1);</span><br><span class="line">&#x2F;&#x2F; 后半递归</span><br><span class="line">QuickSort(v, first + 1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-3">
          <a href="#-3" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="5-堆排序">
          <a href="#5-堆排序" class="heading-link"><i class="fas fa-link"></i></a>5 堆排序</h2>
      <p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ol>

        <h3 id="代码：-4">
          <a href="#代码：-4" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆排序：（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。</span><br><span class="line"></span><br><span class="line">void max_heapify(int arr[], int start, int end) &#123;</span><br><span class="line">&#x2F;&#x2F;建立父节点指标和子节点指标</span><br><span class="line">int dad &#x3D; start;</span><br><span class="line">int son &#x3D; dad * 2 + 1;</span><br><span class="line">while (son &lt;&#x3D; end) &#123; &#x2F;&#x2F;若子节点在范围内才做比较</span><br><span class="line">if (son + 1 &lt;&#x3D; end &amp;&amp; arr[son] &lt; arr[son + 1]) &#x2F;&#x2F;先比较两个子节点指标，选择最大的</span><br><span class="line">son++;</span><br><span class="line">if (arr[dad] &gt; arr[son]) &#x2F;&#x2F;如果父节点大于子节点代表调整完成，直接跳出函数</span><br><span class="line">return;</span><br><span class="line">else &#123; &#x2F;&#x2F;否则交换父子內容再继续子节点与孙节点比較</span><br><span class="line">swap(arr[dad], arr[son]);</span><br><span class="line">dad &#x3D; son;</span><br><span class="line">son &#x3D; dad * 2 + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">&#x2F;&#x2F;初始化，i从最后一个父节点开始调整</span><br><span class="line">for (int i &#x3D; len &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">max_heapify(arr, i, len - 1);</span><br><span class="line">&#x2F;&#x2F;先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完成</span><br><span class="line">for (int i &#x3D; len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">swap(arr[0], arr[i]);</span><br><span class="line">max_heapify(arr, 0, i - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int arr[] &#x3D; &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span><br><span class="line">int len &#x3D; (int) sizeof(arr) &#x2F; sizeof(*arr);</span><br><span class="line">heap_sort(arr, len);</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-4">
          <a href="#-4" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="6-归并排序">
          <a href="#6-归并排序" class="heading-link"><i class="fas fa-link"></i></a>6 归并排序</h2>
      <p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>算法思想</strong>：1.把长度为n的输入序列分成两个长度为n/2的子序列；2. 对这两个子序列分别采用归并排序；3. 将两个排序好的子序列合并成一个最终的排序序列。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hia9hibzYxy67BFFCxI2L5FAmtZWiahfIc0XasMFvIRH6sXjnGwpXMjYCw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">归并排序动图演示</p>

        <h3 id="代码：-5">
          <a href="#代码：-5" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void print(int a[], int n)&#123;</span><br><span class="line">  for(int j&#x3D; 0; j&lt;n; j++)&#123;</span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]</span><br><span class="line">void Merge(ElemType *r,ElemType *rf, int i, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">  int j,k;</span><br><span class="line">  for(j&#x3D;m+1,k&#x3D;i; i&lt;&#x3D;m &amp;&amp; j &lt;&#x3D;n ; ++k)&#123;</span><br><span class="line">    if(r[j] &lt; r[i]) rf[k] &#x3D; r[j++];</span><br><span class="line">    else rf[k] &#x3D; r[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  while(i &lt;&#x3D; m)  rf[k++] &#x3D; r[i++];</span><br><span class="line">  while(j &lt;&#x3D; n)  rf[k++] &#x3D; r[j++];</span><br><span class="line">  print(rf,n+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(ElemType *r, ElemType *rf, int lenght)</span><br><span class="line">&#123;</span><br><span class="line">  int len &#x3D; 1;</span><br><span class="line">  ElemType *q &#x3D; r ;</span><br><span class="line">  ElemType *tmp ;</span><br><span class="line">  while(len &lt; lenght) &#123;</span><br><span class="line">    int s &#x3D; len;</span><br><span class="line">    len &#x3D; 2 * s ;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while(i+ len &lt;lenght)&#123;</span><br><span class="line">      Merge(q, rf,  i, i+ s-1, i+ len-1 ); &#x2F;&#x2F;对等长的两个子表合并</span><br><span class="line">      i &#x3D; i+ len;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i + s &lt; lenght)&#123;</span><br><span class="line">      Merge(q, rf,  i, i+ s -1, lenght -1); &#x2F;&#x2F;对不等长的两个子表合并</span><br><span class="line">    &#125;</span><br><span class="line">    tmp &#x3D; q; q &#x3D; rf; rf &#x3D; tmp; &#x2F;&#x2F;交换q,rf，以保证下一趟归并时，仍从q 归并到rf</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a[10] &#x3D; &#123;2，3,4，5,15,19,26,27,36,38,44,46,47,48,50&#125;;</span><br><span class="line">  int b[10];</span><br><span class="line">  MergeSort(a, b, 15);</span><br><span class="line">  print(b,15);</span><br><span class="line">  cout&lt;&lt;&quot;结果：&quot;;</span><br><span class="line">  print(a,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-5">
          <a href="#-5" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="7-希尔排序">
          <a href="#7-希尔排序" class="heading-link"><i class="fas fa-link"></i></a>7 希尔排序</h2>
      <p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序.</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hZFACwMvVG9IMqENiaAibSR5wPgJCkZH8kmfOZcrUpWyxLWpG5Rh11JSg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">希尔排序动图演示</p>

        <h3 id="代码：-6">
          <a href="#代码：-6" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void shell_sort(T array[], int length) &#123;</span><br><span class="line">    int h &#x3D; 1;</span><br><span class="line">    while (h &lt; length &#x2F; 3) &#123;</span><br><span class="line">        h &#x3D; 3 * h + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (h &gt;&#x3D; 1) &#123;</span><br><span class="line">        for (int i &#x3D; h; i &lt; length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i; j &gt;&#x3D; h &amp;&amp; array[j] &lt; array[j - h]; j -&#x3D; h) &#123;</span><br><span class="line">                std::swap(array[j], array[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h &#x3D; h &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-6">
          <a href="#-6" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="8-计数排序">
          <a href="#8-计数排序" class="heading-link"><i class="fas fa-link"></i></a>8 计数排序</h2>
      <p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<ul>
<li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li>
<li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
</ul>
<p><strong>算法思想</strong>：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQNqdTja9dCGls0V9Ve7JolUmUxbVtHlrybsmNC84jWHHibL9kLicw8BQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">计数排序动图演示</p>

        <h3 id="代码：-7">
          <a href="#代码：-7" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计数排序</span><br><span class="line">void CountSort(vector&lt;int&gt;&amp; vecRaw, vector&lt;int&gt;&amp; vecObj)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 确保待排序容器非空</span><br><span class="line">if (vecRaw.size() &#x3D;&#x3D; 0)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span><br><span class="line">int vecCountLength &#x3D; (*max_element(begin(vecRaw), end(vecRaw))) + 1;</span><br><span class="line">vector&lt;int&gt; vecCount(vecCountLength, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计每个键值出现的次数</span><br><span class="line">for (int i &#x3D; 0; i &lt; vecRaw.size(); i++)</span><br><span class="line">vecCount[vecRaw[i]]++;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 后面的键值出现的位置为前面所有键值出现的次数之和</span><br><span class="line">for (int i &#x3D; 1; i &lt; vecCountLength; i++)</span><br><span class="line">vecCount[i] +&#x3D; vecCount[i - 1];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将键值放到目标位置</span><br><span class="line">for (int i &#x3D; vecRaw.size(); i &gt; 0; i--)&#x2F;&#x2F; 此处逆序是为了保持相同键值的稳定性</span><br><span class="line">vecObj[--vecCount[vecRaw[i - 1]]] &#x3D; vecRaw[i - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; vecRaw &#x3D; &#123; 0,5,7,9,6,3,4,5,2,8,6,9,2,1 &#125;;</span><br><span class="line">vector&lt;int&gt; vecObj(vecRaw.size(), 0);</span><br><span class="line"></span><br><span class="line">CountSort(vecRaw, vecObj);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; vecObj.size(); ++i)</span><br><span class="line">cout &lt;&lt; vecObj[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-7">
          <a href="#-7" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="9-桶排序">
          <a href="#9-桶排序" class="heading-link"><i class="fas fa-link"></i></a>9 桶排序</h2>
      <p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hjl4T0fCvUq2zCdEcGqyH1ic9bDXVStxQXWcypoAs5VQ499ABm6dicYbA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">桶排序动图演示</p>

        <h3 id="代码：-8">
          <a href="#代码：-8" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue &#x3D; arr[0];</span><br><span class="line">    var maxValue &#x3D; arr[0];</span><br><span class="line">    for (i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE &#x3D; 5;            &#x2F;&#x2F; 设置桶的默认数量为5</span><br><span class="line">    bucketSize &#x3D; bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount &#x3D; Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;</span><br><span class="line">    var buckets &#x3D; new Array(bucketCount);</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) &#x2F; bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      &#x2F;&#x2F; 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j &#x3D; 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-8">
          <a href="#-8" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="10-基数排序">
          <a href="#10-基数排序" class="heading-link"><i class="fas fa-link"></i></a>10 基数排序</h2>
      <p>一种多关键字的排序算法，可用桶排序实现。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hJrHSX1wiaClKuPDnLtLNgZUIQ2NfbYFMlIUaYQ6qLGaoiaiaRXJLXV9bg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">基数排序动图演示</p>

        <h3 id="代码：-9">
          <a href="#代码：-9" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int maxbit(int data[], int n) &#x2F;&#x2F;辅助函数，求数据的最大位数</span><br><span class="line">&#123;</span><br><span class="line">    int maxData &#x3D; data[0];&#x2F;&#x2F;&#x2F;&lt; 最大数</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxData &lt; data[i])</span><br><span class="line">            maxData &#x3D; data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int d &#x3D; 1;</span><br><span class="line">    int p &#x3D; 10;</span><br><span class="line">    while (maxData &gt;&#x3D; p)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;p *&#x3D; 10; &#x2F;&#x2F; Maybe overflow</span><br><span class="line">        maxData &#x2F;&#x3D; 10;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#x2F;*    int d &#x3D; 1; &#x2F;&#x2F;保存最大的位数</span><br><span class="line">    int p &#x3D; 10;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while(data[i] &gt;&#x3D; p)</span><br><span class="line">        &#123;</span><br><span class="line">            p *&#x3D; 10;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void radixsort(int data[], int n) &#x2F;&#x2F;基数排序</span><br><span class="line">&#123;</span><br><span class="line">    int d &#x3D; maxbit(data, n);</span><br><span class="line">    int *tmp &#x3D; new int[n];</span><br><span class="line">    int *count &#x3D; new int[10]; &#x2F;&#x2F;计数器</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int radix &#x3D; 1;</span><br><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; d; i++) &#x2F;&#x2F;进行d次排序</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; 10; j++)</span><br><span class="line">            count[j] &#x3D; 0; &#x2F;&#x2F;每次分配前清空计数器</span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k &#x3D; (data[j] &#x2F; radix) % 10; &#x2F;&#x2F;统计每个桶中的记录数</span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j &#x3D; 1; j &lt; 10; j++)</span><br><span class="line">            count[j] &#x3D; count[j - 1] + count[j]; &#x2F;&#x2F;将tmp中的位置依次分配给每个桶</span><br><span class="line">        for(j &#x3D; n - 1; j &gt;&#x3D; 0; j--) &#x2F;&#x2F;将所有桶中记录依次收集到tmp中</span><br><span class="line">        &#123;</span><br><span class="line">            k &#x3D; (data[j] &#x2F; radix) % 10;</span><br><span class="line">            tmp[count[k] - 1] &#x3D; data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++) &#x2F;&#x2F;将临时数组的内容复制到data中</span><br><span class="line">            data[j] &#x3D; tmp[j];</span><br><span class="line">        radix &#x3D; radix * 10;</span><br><span class="line">    &#125;</span><br><span class="line">    delete []tmp;</span><br><span class="line">    delete []count;</span><br><span class="line">&#125;</span><br><span class="line">© 2020 GitHub, Inc.</span><br></pre></td></tr></table></div></figure>

</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ END ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">Author: </span><span class="copyright-author__value"><a href="http://121.196.57.169/blog">ydm</a></span></div><div class="copyright-link"><span class="copyright-link__name">Link: </span><span class="copyright-link__value"><a href="http://121.196.57.169/blog/2020/06/30/10_%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA+_C_%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%89/">http://121.196.57.169/blog/2020/06/30/10_%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA+_C_%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%89/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">Copyright: </span><span class="copyright-notice__value">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> unless stating additionally</span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/blog/2020/07/01/ceshi/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">ceshi</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/blog/2020/06/24/hello-world/"><span class="paginator-prev__text">Hello World</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Catalog</span><span class="sidebar-nav-ov">Overview</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-大经典排序算法（动图演示-C-语言代码）"><span class="toc-number">1.</span> <span class="toc-text">
          10 大经典排序算法（动图演示+ C 语言代码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时间、空间复杂度比较"><span class="toc-number">2.</span> <span class="toc-text">
          时间、空间复杂度比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-number">3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-冒泡排序"><span class="toc-number">4.</span> <span class="toc-text">
          1 冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码："><span class="toc-number">4.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-选择排序"><span class="toc-number">5.</span> <span class="toc-text">
          2 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-1"><span class="toc-number">5.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">6.</span> <span class="toc-text">
          ** **</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-插入排序"><span class="toc-number">7.</span> <span class="toc-text">
          3 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-2"><span class="toc-number">7.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">8.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-快速排序"><span class="toc-number">9.</span> <span class="toc-text">
          4 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-3"><span class="toc-number">9.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-3"><span class="toc-number">10.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-堆排序"><span class="toc-number">11.</span> <span class="toc-text">
          5 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-4"><span class="toc-number">11.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-4"><span class="toc-number">12.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-归并排序"><span class="toc-number">13.</span> <span class="toc-text">
          6 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-5"><span class="toc-number">13.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-5"><span class="toc-number">14.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-希尔排序"><span class="toc-number">15.</span> <span class="toc-text">
          7 希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-6"><span class="toc-number">15.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-6"><span class="toc-number">16.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-计数排序"><span class="toc-number">17.</span> <span class="toc-text">
          8 计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-7"><span class="toc-number">17.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-7"><span class="toc-number">18.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-桶排序"><span class="toc-number">19.</span> <span class="toc-text">
          9 桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-8"><span class="toc-number">19.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-8"><span class="toc-number">20.</span> <span class="toc-text">
          </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-基数排序"><span class="toc-number">21.</span> <span class="toc-text">
          10 基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码：-9"><span class="toc-number">21.1.</span> <span class="toc-text">
          代码：</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/blog/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">You have read </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>ydm</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/blog/js/utils.js?v=2.0.1"></script><script src="/blog/js/stun-boot.js?v=2.0.1"></script><script src="/blog/js/scroll.js?v=2.0.1"></script><script src="/blog/js/header.js?v=2.0.1"></script><script src="/blog/js/sidebar.js?v=2.0.1"></script></body></html>