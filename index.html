<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/blog/images/icons/favicon-16x16.png?v=2.0.1" type="image/png" sizes="16x16"><link rel="icon" href="/blog/images/icons/favicon-32x32.png?v=2.0.1" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://121.196.57.169/blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ydm">
<meta name="twitter:card" content="summary"><meta name="keywords" content="ydm, Hexo"><meta name="description" content=""><title>Hexo</title><link ref="canonical" href="http://121.196.57.169/blog/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/blog/css/index.css?v=2.0.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/blog/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Hexo</div><div class="header-banner-info__subtitle"></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/blog/2020/07/03/%E7%AE%97%E6%B3%95/">算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-07-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="十大经典排序算法（动图演示）">
          <a href="#十大经典排序算法（动图演示）" class="heading-link"><i class="fas fa-link"></i></a>十大经典排序算法（动图演示）</h1>
      
        <h3 id="0、算法概述">
          <a href="#0、算法概述" class="heading-link"><i class="fas fa-link"></i></a>0、算法概述</h3>
      
        <h4 id="0-1-算法分类">
          <a href="#0-1-算法分类" class="heading-link"><i class="fas fa-link"></i></a>0.1 算法分类</h4>
      <p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li>
</ul>
<p><img src="/blog/images/pasted-4.png" alt="upload successful"></p>

        <h4 id="0-2-算法复杂度">
          <a href="#0-2-算法复杂度" class="heading-link"><i class="fas fa-link"></i></a>0.2 算法复杂度</h4>
      <p><img src="/blog/images/pasted-5.png" alt="upload successful"></p>
<p><strong>0.3 相关概念</strong></p>
<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机</li>
</ul>
<p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p>

        <h3 id="1、冒泡排序（Bubble-Sort）">
          <a href="#1、冒泡排序（Bubble-Sort）" class="heading-link"><i class="fas fa-link"></i></a>1、冒泡排序（Bubble Sort）</h3>
      <p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>

        <h4 id="1-1-算法描述">
          <a href="#1-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>1.1 算法描述</h4>
      <ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<p><strong>1.2 动图演示</strong></p>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img"></p>

        <h4 id="1-3-代码实现">
          <a href="#1-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>1.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">bubbleSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(vari = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(varj = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;       <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                vartemp = arr[j+<span class="number">1</span>];       <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="2、选择排序（Selection-Sort）">
          <a href="#2、选择排序（Selection-Sort）" class="heading-link"><i class="fas fa-link"></i></a>2、选择排序（Selection Sort）</h3>
      <p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>

        <h4 id="2-1-算法描述">
          <a href="#2-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>2.1 算法描述</h4>
      <p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>

        <h4 id="2-2-动图演示">
          <a href="#2-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>2.2 动图演示</h4>
      <p><img src="/blog/images/pasted-6.png" alt="upload successful"></p>

        <h4 id="2-3-代码实现">
          <a href="#2-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>2.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">selectionSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    varminIndex, temp;</span><br><span class="line">    <span class="keyword">for</span>(vari = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(varj = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;    <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2-4-算法分析">
          <a href="#2-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>2.4 算法分析</h4>
      <p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>

        <h3 id="3、插入排序（Insertion-Sort）">
          <a href="#3、插入排序（Insertion-Sort）" class="heading-link"><i class="fas fa-link"></i></a>3、插入排序（Insertion Sort）</h3>
      <p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>

        <h4 id="3-1-算法描述">
          <a href="#3-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>3.1 算法描述</h4>
      <p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>

        <h4 id="3-2-动图演示">
          <a href="#3-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>3.2 动图演示</h4>
      <p><img src="/blog/images/pasted-7.png" alt="upload successful"></p>

        <h4 id="3-2-代码实现">
          <a href="#3-2-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.2 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">insertionSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    varpreIndex, current;</span><br><span class="line">    <span class="keyword">for</span>(vari = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3-4-算法分析">
          <a href="#3-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>3.4 算法分析</h4>
      <p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>

        <h3 id="4、希尔排序（Shell-Sort）">
          <a href="#4、希尔排序（Shell-Sort）" class="heading-link"><i class="fas fa-link"></i></a>4、希尔排序（Shell Sort）</h3>
      <p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>

        <h4 id="4-1-算法描述">
          <a href="#4-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>4.1 算法描述</h4>
      <p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>

        <h4 id="4-2-动图演示">
          <a href="#4-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>4.2 动图演示</h4>
      <p><img src="/blog/images/pasted-8.png" alt="upload successful"></p>

        <h4 id="4-3-代码实现">
          <a href="#4-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改于 2019-03-06</span></span><br><span class="line"><span class="function">function <span class="title">shellSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(vargap = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = Math.<span class="built_in">floor</span>(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class="line">        <span class="keyword">for</span>(vari = gap; i &lt; len; i++) &#123;</span><br><span class="line">            varj = i;</span><br><span class="line">            varcurrent = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="4-4-算法分析">
          <a href="#4-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>4.4 算法分析</h4>
      <p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p>

        <h3 id="5、归并排序（Merge-Sort）">
          <a href="#5、归并排序（Merge-Sort）" class="heading-link"><i class="fas fa-link"></i></a>5、归并排序（Merge Sort）</h3>
      <p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>

        <h4 id="5-1-算法描述">
          <a href="#5-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>5.1 算法描述</h4>
      <ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>

        <h4 id="5-2-动图演示">
          <a href="#5-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>5.2 动图演示</h4>
      <p><img src="/blog/images/pasted-9.png" alt="upload successful"></p>

        <h4 id="5-3-代码实现">
          <a href="#5-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">mergeSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        returnarr;</span><br><span class="line">    &#125;</span><br><span class="line">    varmiddle = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    returnmerge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">merge</span><span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    varresult = [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    returnresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-算法分析">
          <a href="#5-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>5.4 算法分析</h4>
      <p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>

        <h3 id="6、快速排序（Quick-Sort）">
          <a href="#6、快速排序（Quick-Sort）" class="heading-link"><i class="fas fa-link"></i></a>6、快速排序（Quick Sort）</h3>
      <p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>

        <h4 id="6-1-算法描述">
          <a href="#6-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>6.1 算法描述</h4>
      <p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>

        <h4 id="6-2-动图演示">
          <a href="#6-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>6.2 动图演示</h4>
      <p><img src="/blog/images/pasted-10.png" alt="upload successful"></p>

        <h4 id="6-3-代码实现">
          <a href="#6-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>6.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">quickSort</span><span class="params">(arr, left, right)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left =typeofleft !='number'? 0 : left,</span><br><span class="line">        right =typeofright !='number'? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">partition</span><span class="params">(arr, left ,right)</span> </span>&#123;    <span class="comment">// 分区操作</span></span><br><span class="line">    varpivot = left,                     <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(vari = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    returnindex<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">    vartemp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7、堆排序（Heap-Sort）">
          <a href="#7、堆排序（Heap-Sort）" class="heading-link"><i class="fas fa-link"></i></a>7、堆排序（Heap Sort）</h3>
      <p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>

        <h4 id="7-1-算法描述">
          <a href="#7-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>7.1 算法描述</h4>
      <ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>

        <h4 id="7-2-动图演示">
          <a href="#7-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>7.2 动图演示</h4>
      <p><img src="/blog/images/pasted-11.png" alt="upload successful"></p>

        <h4 id="7-3-代码实现">
          <a href="#7-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>7.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">varlen;   <span class="comment">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">buildMaxHeap</span><span class="params">(arr)</span> </span>&#123;  <span class="comment">// 建立大顶堆</span></span><br><span class="line">    len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(vari = Math.<span class="built_in">floor</span>(len/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">heapify</span><span class="params">(arr, i)</span> </span>&#123;    <span class="comment">// 堆调整</span></span><br><span class="line">    varleft = <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">        right = <span class="number">2</span> * i + <span class="number">2</span>,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">    vartemp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">heapSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(vari = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="8、计数排序（Counting-Sort）">
          <a href="#8、计数排序（Counting-Sort）" class="heading-link"><i class="fas fa-link"></i></a>8、计数排序（Counting Sort）</h3>
      <p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>

        <h4 id="8-1-算法描述">
          <a href="#8-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>8.1 算法描述</h4>
      <ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>

        <h4 id="8-2-动图演示">
          <a href="#8-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>8.2 动图演示</h4>
      <p><img src="/blog/images/pasted-12.png" alt="upload successful"></p>

        <h4 id="8-3-代码实现">
          <a href="#8-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>8.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">countingSort</span><span class="params">(arr, maxValue)</span> </span>&#123;</span><br><span class="line">    varbucket =newArray(maxValue + <span class="number">1</span>),</span><br><span class="line">        sortedIndex = <span class="number">0</span>;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(vari = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(varj = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="8-4-算法分析">
          <a href="#8-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>8.4 算法分析</h4>
      <p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>

        <h3 id="9、桶排序（Bucket-Sort）">
          <a href="#9、桶排序（Bucket-Sort）" class="heading-link"><i class="fas fa-link"></i></a>9、桶排序（Bucket Sort）</h3>
      <p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>

        <h4 id="9-1-算法描述">
          <a href="#9-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>9.1 算法描述</h4>
      <ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ul>

        <h4 id="9-2-图片演示">
          <a href="#9-2-图片演示" class="heading-link"><i class="fas fa-link"></i></a>9.2 图片演示</h4>
      <p><img src="/blog/images/pasted-13.png" alt="upload successful"></p>

        <h4 id="9-3-代码实现">
          <a href="#9-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>9.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">bucketSort</span><span class="params">(arr, bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      returnarr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    vari;</span><br><span class="line">    varminValue = arr[<span class="number">0</span>];</span><br><span class="line">    varmaxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];               <span class="comment">// 输入数据的最小值</span></span><br><span class="line">      &#125;elseif(arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];               <span class="comment">// 输入数据的最大值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 桶的初始化</span></span><br><span class="line">    varDEFAULT_BUCKET_SIZE = <span class="number">5</span>;           <span class="comment">// 设置桶的默认数量为5</span></span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    varbucketCount = Math.<span class="built_in">floor</span>((maxValue - minValue) / bucketSize) + <span class="number">1</span>;  </span><br><span class="line">    varbuckets =newArray(bucketCount);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.<span class="built_in">floor</span>((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                     <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="keyword">for</span>(varj = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="9-4-算法分析">
          <a href="#9-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>9.4 算法分析</h4>
      <p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>

        <h3 id="10、基数排序（Radix-Sort）">
          <a href="#10、基数排序（Radix-Sort）" class="heading-link"><i class="fas fa-link"></i></a>10、基数排序（Radix Sort）</h3>
      <p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>

        <h4 id="10-1-算法描述">
          <a href="#10-1-算法描述" class="heading-link"><i class="fas fa-link"></i></a>10.1 算法描述</h4>
      <ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>

        <h4 id="10-2-动图演示">
          <a href="#10-2-动图演示" class="heading-link"><i class="fas fa-link"></i></a>10.2 动图演示</h4>
      <p><img src="/blog/images/pasted-14.png" alt="upload successful"></p>

        <h4 id="10-3-代码实现">
          <a href="#10-3-代码实现" class="heading-link"><i class="fas fa-link"></i></a>10.3 代码实现</h4>
      <figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">varcounter = [];</span><br><span class="line"><span class="function">function <span class="title">radixSort</span><span class="params">(arr, maxDigit)</span> </span>&#123;</span><br><span class="line">    varmod = <span class="number">10</span>;</span><br><span class="line">    vardev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(vari = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(varj = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            varbucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        varpos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(varj = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">            varvalue =null;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=null) &#123;</span><br><span class="line">                <span class="keyword">while</span>((value = counter[j].shift()) !=null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="10-4-算法分析">
          <a href="#10-4-算法分析" class="heading-link"><i class="fas fa-link"></i></a>10.4 算法分析</h4>
      <p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/blog/2020/07/01/ceshi/">ceshi</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-07-01</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-02</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><img src="http://121.196.57.169/blog/2020/07/01/ceshi/aaa.jpg" alt="aaa"></p>
<p><img src="http://121.196.57.169/blog/2020/07/01/ceshi/aaa.jpg" alt="bbb"><br><img src="/blog/images/pasted-0.png" alt="upload successful"></p>
<p><img src="/blog/images/pasted-1.png" alt="upload successful"></p>
<p><img src="/blog/images/pasted-1.png" alt="upload successful"><br><img src="http://121.196.57.169/blog/2020/07/01/ceshi/_post/ceshi/aaa.jpg" alt="upload successful"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/blog/2020/06/30/10_%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA+_C_%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%EF%BC%89/">10_大经典排序算法（动图演示+_C_语言代码）</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-30</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-07-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="10-大经典排序算法（动图演示-C-语言代码）">
          <a href="#10-大经典排序算法（动图演示-C-语言代码）" class="heading-link"><i class="fas fa-link"></i></a>10 大经典排序算法（动图演示+ C 语言代码）</h2>
      
        <h2 id="时间、空间复杂度比较">
          <a href="#时间、空间复杂度比较" class="heading-link"><i class="fas fa-link"></i></a>时间、空间复杂度比较</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th align="left">排序算法</th>
<th align="left">平均时间复杂度</th>
<th align="left">最差时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">数据对象稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td align="left">O(n2)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">选择排序</td>
<td align="left">O(n2)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">数组不稳定、链表稳定</td>
</tr>
<tr>
<td align="left">插入排序</td>
<td align="left">O(n2)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">快速排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n2)</td>
<td align="left">O(log2n)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">归并排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td align="left">O(n*log2n)</td>
<td align="left">O(n2)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">计数排序</td>
<td align="left">O(n+m)</td>
<td align="left">O(n+m)</td>
<td align="left">O(n+m)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">桶排序</td>
<td align="left">O(n)</td>
<td align="left">O(n)</td>
<td align="left">O(m)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">基数排序</td>
<td align="left">O(k*n)</td>
<td align="left">O(n2)</td>
<td align="left"></td>
<td align="left">稳定</td>
</tr>
</tbody></table></div>
<h2 id><a href="#" class="headerlink" title></a></h2>
        <h2 id="1-冒泡排序">
          <a href="#1-冒泡排序" class="heading-link"><i class="fas fa-link"></i></a>1 冒泡排序</h2>
      <p><strong>算法思想</strong>：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hKfmJibLGNooo53Viahqkd8Fu4P2cfibia4m0VJiaUmB5gGfsUgKISIMG4EQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">冒泡排序动图演示</p>

        <h3 id="代码：">
          <a href="#代码：" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i &#x3D;0 ; i&lt; n-1; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    for(int j &#x3D; 0; j &lt; n-i-1; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      if(a[j] &gt; a[j+1])</span><br><span class="line">      &#123;</span><br><span class="line">        int tmp &#x3D; a[j] ;  &#x2F;&#x2F;交换</span><br><span class="line">        a[j] &#x3D; a[j+1] ;</span><br><span class="line">        a[j+1] &#x3D; tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="2-选择排序">
          <a href="#2-选择排序" class="heading-link"><i class="fas fa-link"></i></a>2 选择排序</h2>
      <p><strong>算法思想</strong>：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li>以此类推，直到所有元素均排序完毕</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9htSXlhWTMfA3icyrX13JjSgZSOibibH0qaiccvQLPryqRiawiaLYaqKSOTJjg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">选择排序动图演示</p>

        <h3 id="代码：-1">
          <a href="#代码：-1" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex &#x3D; i;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F; 寻找最小的数</span><br><span class="line">                minIndex &#x3D; j;                 &#x2F;&#x2F; 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[minIndex];</span><br><span class="line">        arr[minIndex] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-1">
          <a href="#-1" class="heading-link"><i class="fas fa-link"></i></a>** **</h2>
      
        <h2 id="3-插入排序">
          <a href="#3-插入排序" class="heading-link"><i class="fas fa-link"></i></a>3 插入排序</h2>
      <p>**<br>**</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQ5xnBplCB1JYwrkCvJLfr0cr7DDTZY8razp7TLlfibIQkQtBdbLn0ibg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">插入排序动图演示</p>

        <h3 id="代码：-2">
          <a href="#代码：-2" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void print(int a[], int n ,int i)&#123;</span><br><span class="line">  cout&lt;&lt;i &lt;&lt;&quot;:&quot;;</span><br><span class="line">  for(int j&#x3D; 0; j&lt;8; j++)&#123;</span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void InsertSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">  for(int i&#x3D; 1; i&lt;n; i++)&#123;</span><br><span class="line">    if(a[i] &lt; a[i-1])&#123;   &#x2F;&#x2F;若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span><br><span class="line">      int j&#x3D; i-1;</span><br><span class="line">      int x &#x3D; a[i];     &#x2F;&#x2F;复制为哨兵，即存储待排序元素</span><br><span class="line">      a[i] &#x3D; a[i-1];           &#x2F;&#x2F;先后移一个元素</span><br><span class="line">      while(x &lt; a[j])&#123;   &#x2F;&#x2F;查找在有序表的插入位置</span><br><span class="line">        a[j+1] &#x3D; a[j];</span><br><span class="line">        j--;     &#x2F;&#x2F;元素后移</span><br><span class="line">      &#125;</span><br><span class="line">      a[j+1] &#x3D; x;     &#x2F;&#x2F;插入到正确位置</span><br><span class="line">    &#125;</span><br><span class="line">    print(a,n,i);      &#x2F;&#x2F;打印每趟排序的结果</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a[15] &#x3D; &#123;2，3,4,5,15，19，16，27，36，38，44，46，47，48，50&#125;;</span><br><span class="line">  InsertSort(a,15);</span><br><span class="line">  print(a,15,15);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-2">
          <a href="#-2" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="4-快速排序">
          <a href="#4-快速排序" class="heading-link"><i class="fas fa-link"></i></a>4 快速排序</h2>
      <p><strong>算法思想</strong>：</p>
<ol>
<li>选取第一个数为基准</li>
<li>将比基准小的数交换到前面，比基准大的数交换到后面</li>
<li>对左右区间重复第二步，直到各区间只有一个数</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hlEtRTzLNKxgIQHUj7kMAyH7ViaOCyo22r3iaR25ic1LgM4q4llyOBu5SA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">快速排序动图演示</p>

        <h3 id="代码：-3">
          <a href="#代码：-3" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(vector&lt;int&gt;&amp; v, int low, int high) &#123;</span><br><span class="line">if (low &gt;&#x3D; high)&#x2F;&#x2F; 结束标志</span><br><span class="line">return;</span><br><span class="line">int first &#x3D; low;&#x2F;&#x2F; 低位下标</span><br><span class="line">int last &#x3D; high;&#x2F;&#x2F; 高位下标</span><br><span class="line">int key &#x3D; v[first];&#x2F;&#x2F; 设第一个为基准</span><br><span class="line"></span><br><span class="line">while (first &lt; last)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 将比第一个小的移到前面</span><br><span class="line">while (first &lt; last &amp;&amp; v[last] &gt;&#x3D; key)</span><br><span class="line">last--;</span><br><span class="line">if (first &lt; last)</span><br><span class="line">v[first++] &#x3D; v[last];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将比第一个大的移到后面</span><br><span class="line">while (first &lt; last &amp;&amp; v[first] &lt;&#x3D; key)</span><br><span class="line">first++;</span><br><span class="line">if (first &lt; last)</span><br><span class="line">v[last--] &#x3D; v[first];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">v[first] &#x3D; key;</span><br><span class="line">&#x2F;&#x2F; 前半递归</span><br><span class="line">QuickSort(v, low, first - 1);</span><br><span class="line">&#x2F;&#x2F; 后半递归</span><br><span class="line">QuickSort(v, first + 1, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-3">
          <a href="#-3" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="5-堆排序">
          <a href="#5-堆排序" class="heading-link"><i class="fas fa-link"></i></a>5 堆排序</h2>
      <p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ol>

        <h3 id="代码：-4">
          <a href="#代码：-4" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 堆排序：（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。</span><br><span class="line"></span><br><span class="line">void max_heapify(int arr[], int start, int end) &#123;</span><br><span class="line">&#x2F;&#x2F;建立父节点指标和子节点指标</span><br><span class="line">int dad &#x3D; start;</span><br><span class="line">int son &#x3D; dad * 2 + 1;</span><br><span class="line">while (son &lt;&#x3D; end) &#123; &#x2F;&#x2F;若子节点在范围内才做比较</span><br><span class="line">if (son + 1 &lt;&#x3D; end &amp;&amp; arr[son] &lt; arr[son + 1]) &#x2F;&#x2F;先比较两个子节点指标，选择最大的</span><br><span class="line">son++;</span><br><span class="line">if (arr[dad] &gt; arr[son]) &#x2F;&#x2F;如果父节点大于子节点代表调整完成，直接跳出函数</span><br><span class="line">return;</span><br><span class="line">else &#123; &#x2F;&#x2F;否则交换父子內容再继续子节点与孙节点比較</span><br><span class="line">swap(arr[dad], arr[son]);</span><br><span class="line">dad &#x3D; son;</span><br><span class="line">son &#x3D; dad * 2 + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">&#x2F;&#x2F;初始化，i从最后一个父节点开始调整</span><br><span class="line">for (int i &#x3D; len &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">max_heapify(arr, i, len - 1);</span><br><span class="line">&#x2F;&#x2F;先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完成</span><br><span class="line">for (int i &#x3D; len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">swap(arr[0], arr[i]);</span><br><span class="line">max_heapify(arr, 0, i - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int arr[] &#x3D; &#123; 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 &#125;;</span><br><span class="line">int len &#x3D; (int) sizeof(arr) &#x2F; sizeof(*arr);</span><br><span class="line">heap_sort(arr, len);</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; &#39; &#39;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-4">
          <a href="#-4" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="6-归并排序">
          <a href="#6-归并排序" class="heading-link"><i class="fas fa-link"></i></a>6 归并排序</h2>
      <p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>算法思想</strong>：1.把长度为n的输入序列分成两个长度为n/2的子序列；2. 对这两个子序列分别采用归并排序；3. 将两个排序好的子序列合并成一个最终的排序序列。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hia9hibzYxy67BFFCxI2L5FAmtZWiahfIc0XasMFvIRH6sXjnGwpXMjYCw/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">归并排序动图演示</p>

        <h3 id="代码：-5">
          <a href="#代码：-5" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void print(int a[], int n)&#123;</span><br><span class="line">  for(int j&#x3D; 0; j&lt;n; j++)&#123;</span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]</span><br><span class="line">void Merge(ElemType *r,ElemType *rf, int i, int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">  int j,k;</span><br><span class="line">  for(j&#x3D;m+1,k&#x3D;i; i&lt;&#x3D;m &amp;&amp; j &lt;&#x3D;n ; ++k)&#123;</span><br><span class="line">    if(r[j] &lt; r[i]) rf[k] &#x3D; r[j++];</span><br><span class="line">    else rf[k] &#x3D; r[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  while(i &lt;&#x3D; m)  rf[k++] &#x3D; r[i++];</span><br><span class="line">  while(j &lt;&#x3D; n)  rf[k++] &#x3D; r[j++];</span><br><span class="line">  print(rf,n+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(ElemType *r, ElemType *rf, int lenght)</span><br><span class="line">&#123;</span><br><span class="line">  int len &#x3D; 1;</span><br><span class="line">  ElemType *q &#x3D; r ;</span><br><span class="line">  ElemType *tmp ;</span><br><span class="line">  while(len &lt; lenght) &#123;</span><br><span class="line">    int s &#x3D; len;</span><br><span class="line">    len &#x3D; 2 * s ;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    while(i+ len &lt;lenght)&#123;</span><br><span class="line">      Merge(q, rf,  i, i+ s-1, i+ len-1 ); &#x2F;&#x2F;对等长的两个子表合并</span><br><span class="line">      i &#x3D; i+ len;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i + s &lt; lenght)&#123;</span><br><span class="line">      Merge(q, rf,  i, i+ s -1, lenght -1); &#x2F;&#x2F;对不等长的两个子表合并</span><br><span class="line">    &#125;</span><br><span class="line">    tmp &#x3D; q; q &#x3D; rf; rf &#x3D; tmp; &#x2F;&#x2F;交换q,rf，以保证下一趟归并时，仍从q 归并到rf</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  int a[10] &#x3D; &#123;2，3,4，5,15,19,26,27,36,38,44,46,47,48,50&#125;;</span><br><span class="line">  int b[10];</span><br><span class="line">  MergeSort(a, b, 15);</span><br><span class="line">  print(b,15);</span><br><span class="line">  cout&lt;&lt;&quot;结果：&quot;;</span><br><span class="line">  print(a,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-5">
          <a href="#-5" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="7-希尔排序">
          <a href="#7-希尔排序" class="heading-link"><i class="fas fa-link"></i></a>7 希尔排序</h2>
      <p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序.</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hZFACwMvVG9IMqENiaAibSR5wPgJCkZH8kmfOZcrUpWyxLWpG5Rh11JSg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">希尔排序动图演示</p>

        <h3 id="代码：-6">
          <a href="#代码：-6" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void shell_sort(T array[], int length) &#123;</span><br><span class="line">    int h &#x3D; 1;</span><br><span class="line">    while (h &lt; length &#x2F; 3) &#123;</span><br><span class="line">        h &#x3D; 3 * h + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    while (h &gt;&#x3D; 1) &#123;</span><br><span class="line">        for (int i &#x3D; h; i &lt; length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i; j &gt;&#x3D; h &amp;&amp; array[j] &lt; array[j - h]; j -&#x3D; h) &#123;</span><br><span class="line">                std::swap(array[j], array[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h &#x3D; h &#x2F; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-6">
          <a href="#-6" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="8-计数排序">
          <a href="#8-计数排序" class="heading-link"><i class="fas fa-link"></i></a>8 计数排序</h2>
      <p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<ul>
<li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li>
<li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
</ul>
<p><strong>算法思想</strong>：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQNqdTja9dCGls0V9Ve7JolUmUxbVtHlrybsmNC84jWHHibL9kLicw8BQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">计数排序动图演示</p>

        <h3 id="代码：-7">
          <a href="#代码：-7" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计数排序</span><br><span class="line">void CountSort(vector&lt;int&gt;&amp; vecRaw, vector&lt;int&gt;&amp; vecObj)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 确保待排序容器非空</span><br><span class="line">if (vecRaw.size() &#x3D;&#x3D; 0)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span><br><span class="line">int vecCountLength &#x3D; (*max_element(begin(vecRaw), end(vecRaw))) + 1;</span><br><span class="line">vector&lt;int&gt; vecCount(vecCountLength, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计每个键值出现的次数</span><br><span class="line">for (int i &#x3D; 0; i &lt; vecRaw.size(); i++)</span><br><span class="line">vecCount[vecRaw[i]]++;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 后面的键值出现的位置为前面所有键值出现的次数之和</span><br><span class="line">for (int i &#x3D; 1; i &lt; vecCountLength; i++)</span><br><span class="line">vecCount[i] +&#x3D; vecCount[i - 1];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将键值放到目标位置</span><br><span class="line">for (int i &#x3D; vecRaw.size(); i &gt; 0; i--)&#x2F;&#x2F; 此处逆序是为了保持相同键值的稳定性</span><br><span class="line">vecObj[--vecCount[vecRaw[i - 1]]] &#x3D; vecRaw[i - 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; vecRaw &#x3D; &#123; 0,5,7,9,6,3,4,5,2,8,6,9,2,1 &#125;;</span><br><span class="line">vector&lt;int&gt; vecObj(vecRaw.size(), 0);</span><br><span class="line"></span><br><span class="line">CountSort(vecRaw, vecObj);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; vecObj.size(); ++i)</span><br><span class="line">cout &lt;&lt; vecObj[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-7">
          <a href="#-7" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="9-桶排序">
          <a href="#9-桶排序" class="heading-link"><i class="fas fa-link"></i></a>9 桶排序</h2>
      <p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hjl4T0fCvUq2zCdEcGqyH1ic9bDXVStxQXWcypoAs5VQ499ABm6dicYbA/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">桶排序动图演示</p>

        <h3 id="代码：-8">
          <a href="#代码：-8" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue &#x3D; arr[0];</span><br><span class="line">    var maxValue &#x3D; arr[0];</span><br><span class="line">    for (i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE &#x3D; 5;            &#x2F;&#x2F; 设置桶的默认数量为5</span><br><span class="line">    bucketSize &#x3D; bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount &#x3D; Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;</span><br><span class="line">    var buckets &#x3D; new Array(bucketCount);</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) &#x2F; bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      &#x2F;&#x2F; 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j &#x3D; 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="-8">
          <a href="#-8" class="heading-link"><i class="fas fa-link"></i></a></h2>
      
        <h2 id="10-基数排序">
          <a href="#10-基数排序" class="heading-link"><i class="fas fa-link"></i></a>10 基数排序</h2>
      <p>一种多关键字的排序算法，可用桶排序实现。</p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hJrHSX1wiaClKuPDnLtLNgZUIQ2NfbYFMlIUaYQ6qLGaoiaiaRXJLXV9bg/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1" style alt="img">基数排序动图演示</p>

        <h3 id="代码：-9">
          <a href="#代码：-9" class="heading-link"><i class="fas fa-link"></i></a>代码：</h3>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">int maxbit(int data[], int n) &#x2F;&#x2F;辅助函数，求数据的最大位数</span><br><span class="line">&#123;</span><br><span class="line">    int maxData &#x3D; data[0];&#x2F;&#x2F;&#x2F;&lt; 最大数</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxData &lt; data[i])</span><br><span class="line">            maxData &#x3D; data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int d &#x3D; 1;</span><br><span class="line">    int p &#x3D; 10;</span><br><span class="line">    while (maxData &gt;&#x3D; p)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;p *&#x3D; 10; &#x2F;&#x2F; Maybe overflow</span><br><span class="line">        maxData &#x2F;&#x3D; 10;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;</span><br><span class="line">&#x2F;*    int d &#x3D; 1; &#x2F;&#x2F;保存最大的位数</span><br><span class="line">    int p &#x3D; 10;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while(data[i] &gt;&#x3D; p)</span><br><span class="line">        &#123;</span><br><span class="line">            p *&#x3D; 10;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return d;*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">void radixsort(int data[], int n) &#x2F;&#x2F;基数排序</span><br><span class="line">&#123;</span><br><span class="line">    int d &#x3D; maxbit(data, n);</span><br><span class="line">    int *tmp &#x3D; new int[n];</span><br><span class="line">    int *count &#x3D; new int[10]; &#x2F;&#x2F;计数器</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int radix &#x3D; 1;</span><br><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; d; i++) &#x2F;&#x2F;进行d次排序</span><br><span class="line">    &#123;</span><br><span class="line">        for(j &#x3D; 0; j &lt; 10; j++)</span><br><span class="line">            count[j] &#x3D; 0; &#x2F;&#x2F;每次分配前清空计数器</span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k &#x3D; (data[j] &#x2F; radix) % 10; &#x2F;&#x2F;统计每个桶中的记录数</span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j &#x3D; 1; j &lt; 10; j++)</span><br><span class="line">            count[j] &#x3D; count[j - 1] + count[j]; &#x2F;&#x2F;将tmp中的位置依次分配给每个桶</span><br><span class="line">        for(j &#x3D; n - 1; j &gt;&#x3D; 0; j--) &#x2F;&#x2F;将所有桶中记录依次收集到tmp中</span><br><span class="line">        &#123;</span><br><span class="line">            k &#x3D; (data[j] &#x2F; radix) % 10;</span><br><span class="line">            tmp[count[k] - 1] &#x3D; data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j &#x3D; 0; j &lt; n; j++) &#x2F;&#x2F;将临时数组的内容复制到data中</span><br><span class="line">            data[j] &#x3D; tmp[j];</span><br><span class="line">        radix &#x3D; radix * 10;</span><br><span class="line">    &#125;</span><br><span class="line">    delete []tmp;</span><br><span class="line">    delete []count;</span><br><span class="line">&#125;</span><br><span class="line">© 2020 GitHub, Inc.</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/blog/2020/06/24/hello-world/">Hello World</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2020-06-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Welcome to <span class="exturl"><a class="exturl__link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link" href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link" href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link" href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>

        <h2 id="Quick-Start">
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a>Quick Start</h2>
      
        <h3 id="Create-a-new-post">
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link" href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Run-server">
          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a>Run server</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link" href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Generate-static-files">
          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a>Generate static files</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link" href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Deploy-to-remote-sites">
          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a>Deploy to remote sites</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link" href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">hello world</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">4</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/blog/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>ydm</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.1</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/blog/js/utils.js?v=2.0.1"></script><script src="/blog/js/stun-boot.js?v=2.0.1"></script><script src="/blog/js/scroll.js?v=2.0.1"></script><script src="/blog/js/header.js?v=2.0.1"></script><script src="/blog/js/sidebar.js?v=2.0.1"></script></body></html>